{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to Ninja-Crane","text":""},{"location":"#django-ninja-crane","title":"django-ninja-crane","text":"<p>Stripe-style API versioning for Django Ninja.</p> <p>django-ninja-crane adds versioning and migrations to your Django Ninja APIs. When you change your API schemas, clients can keep using older versions, by transforming older api payloads before they reach your view.</p>"},{"location":"#the-problem","title":"The Problem","text":"<p>You've built an API. Users depend on it. Then you need to make a breaking change:</p> <ul> <li>restructuring what fields are where in the schema.</li> <li>changing the type of a field, e.g., from a string to a list of strings.</li> </ul> <p>Traditionally, you have a few (usually painful) options:</p> <ol> <li>Run multiple versions of your application, putting the \"old\" version in a deprecation track.</li> <li>Make multiple NinjaAPI and/or router instances for each version, resulting in multiple views to maintain.</li> </ol>"},{"location":"#the-solution","title":"The Solution","text":"<p>Stripe already has a great solution to this problem:</p> <ul> <li>Your code maintains the latest version of the API</li> <li>Changes between API versions are described as migrations in code: how the schemas changed, and how to migrate   payloads/responses   between versions.</li> <li>API users can stay on \"their\" preferred version of the API, with the migrations reshaping the request into a request   of the latest version, and its response back into a response of the user's version.</li> </ul> <p>Django Ninja Crane provides an easy-to-use implementation of this api versioning methodology, for Django apps using django-ninja.</p> <p>It does this through:</p> <ul> <li>Auto-generated Migration files track schema changes over time (like Django's database migrations)</li> <li>Automatic transformation of requests and responses (payloads, path parameters) between versions</li> <li>Versioned OpenAPI docs with a version selector in Swagger UI</li> <li>Flexible version detection: built-in through request headers, with the ability to plug-in your own logic.</li> </ul>"},{"location":"#in-brief","title":"In brief","text":"<p>Making a new version in django ninja crane consists of the following steps:</p> <ol> <li>You make changes to your API schemas</li> <li><code>makeapimigrations</code> auto-detects how your schemas/endpoints changed between versions and creates an api migration    file, with \"fill-in-the-blank\" functions for you to write when breaking data changes are made.</li> <li>You fill in the blanks: writing transformer functions to handle upgrading/downgrading schema/endpoint data between    versions</li> <li>At runtime, the versioning middleware uses the migration files and their transformation functions to turn a request    into its shape for the latest version, and the api user receives a response in the shape of their older version.</li> </ol> <p></p>"},{"location":"#where-to-start","title":"Where to Start","text":"<p>New to django-ninja-crane? Start with the Quickstart to get up and running.</p> <p>Need configuration details? See the Configuration Reference for all options.</p> <p>Want to understand the design? Read How It Works for the architecture.</p>"},{"location":"#status","title":"Status","text":"<p>django-ninja-crane is at early stages. The core functionality is complete and tested:</p> <ul> <li>API state extraction and delta detection</li> <li>Migration file generation</li> <li>Request/response transformation</li> <li>Django middleware integration</li> <li>Versioned OpenAPI schema generation</li> </ul> <p>The public \"API\" (migration file syntax, middleware extension points, ninjaapi wrappng) should remain stable, but internals like how migration files are generated are still subject to change as the project evolves in supported features.</p>"},{"location":"advanced/custom-version-resolver/","title":"Custom Version Resolver","text":"<p>By default, django-ninja-crane detects the API version from the HTTP header (<code>X-API-Version</code>).</p> <p>You can customize this to use subdomains, URL paths, cookies, query parameters, or any other mechanism by subclassing <code>VersionedAPIMiddleware</code>.</p>"},{"location":"advanced/custom-version-resolver/#subclassing-the-middleware","title":"Subclassing the Middleware","text":"<p>Override the <code>_extract_version</code> method to implement your custom logic:</p> <pre><code>from crane.middleware import VersionedAPIMiddleware\n\nclass MyVersionMiddleware(VersionedAPIMiddleware):\n    def _extract_version(self, request, api) -&gt; str:\n        # Your custom logic here\n\n        # Priority: subdomain &gt; header &gt; cookie &gt; default\n        version = self._from_subdomain(request)\n        if version:\n            return version\n\n        version = request.headers.get(api.version_header)\n        if version:\n            return version\n\n        version = request.COOKIES.get(\"api_version\")\n        if version:\n            return version\n\n        return api.default_version\n\n    def _from_subdomain(self, request) -&gt; str | None:\n        host = request.get_host()\n        if host.startswith(\"v\"):\n            return host.split(\".\")[0][1:]\n        return None\n</code></pre> <p>Register in settings:</p> <pre><code>MIDDLEWARE = [\n    # ...\n    \"myapp.middleware.MyVersionMiddleware\",  # Instead of VersionedAPIMiddleware\n]\n</code></pre>"},{"location":"advanced/custom-version-resolver/#version-validation","title":"Version Validation","text":"<p>The middleware validates that the requested version exists. If you want custom validation:</p> <pre><code>class StrictVersionMiddleware(VersionedAPIMiddleware):\n    def _resolve_version(self, version: str, ctx) -&gt; str | None:\n        # Only allow specific versions\n        allowed = {\"1\", \"2\", \"latest\"}\n        if version not in allowed:\n            return None\n\n        return super()._resolve_version(version, ctx)\n</code></pre>"},{"location":"advanced/custom-version-resolver/#common-patterns","title":"Common Patterns","text":""},{"location":"advanced/custom-version-resolver/#subdomain-versioning","title":"Subdomain Versioning","text":"<p>Extract version from subdomain like <code>v1.api.example.com</code>:</p> <pre><code>class SubdomainVersionMiddleware(VersionedAPIMiddleware):\n    def _extract_version(self, request, api) -&gt; str:\n        host = request.get_host()\n        if host.startswith(\"v\") and \".\" in host:\n            return host.split(\".\")[0][1:]  # \"v1.api.example.com\" \u2192 \"1\"\n        return super()._extract_version(request, api)\n</code></pre>"},{"location":"advanced/custom-version-resolver/#url-path-versioning","title":"URL Path Versioning","text":"<p>Extract version from URL path like <code>/api/v1/users</code>:</p> <pre><code>class PathVersionMiddleware(VersionedAPIMiddleware):\n    def _extract_version(self, request, api) -&gt; str:\n        path = request.path\n        for part in path.split(\"/\"):\n            if part.startswith(\"v\") and part[1:].isdigit():\n                return part[1:]  # \"/api/v1/users\" \u2192 \"1\"\n        return super()._extract_version(request, api)\n</code></pre> <p>Warning</p> <p>URL path versioning requires careful URL configuration. Each version path must route to the same API, and you may need to strip the version prefix before processing.</p>"},{"location":"advanced/custom-version-resolver/#cookie-based-versioning","title":"Cookie-Based Versioning","text":"<p>Store the version preference in a cookie (useful for browser clients):</p> <pre><code>class CookieVersionMiddleware(VersionedAPIMiddleware):\n    def _extract_version(self, request, api) -&gt; str:\n        version = request.COOKIES.get(\"api_version\")\n        if version:\n            return version\n        return super()._extract_version(request, api)\n</code></pre>"},{"location":"advanced/custom-version-resolver/#user-based-versioning","title":"User-Based Versioning","text":"<p>Different users on different versions (assuming your user model has a <code>api_version</code> attribute.</p> <pre><code>class UserVersionMiddleware(VersionedAPIMiddleware):\n    def _extract_version(self, request, api) -&gt; str:\n        if hasattr(request, 'user') and request.user.is_authenticated:\n            version = getattr(request.user, 'api_version', None)\n            if version:\n                return version\n        return super()._extract_version(request, api)\n</code></pre>"},{"location":"advanced/custom-version-resolver/#combining-multiple-strategies","title":"Combining Multiple Strategies","text":"<p>You can combine strategies with fallback:</p> <pre><code>class FlexibleVersionMiddleware(VersionedAPIMiddleware):\n    def _extract_version(self, request, api) -&gt; str:\n        # Try each strategy in order\n        strategies = [\n            self._from_subdomain,\n            self._from_cookie,\n            self._from_user,\n        ]\n\n        for strategy in strategies:\n            version = strategy(request)\n            if version:\n                return version\n\n        # Fall back to default header-based extraction\n        return super()._extract_version(request, api)\n\n    def _from_subdomain(self, request) -&gt; str | None:\n        host = request.get_host()\n        if host.startswith(\"v\") and \".\" in host:\n            return host.split(\".\")[0][1:]\n        return None\n\n    def _from_cookie(self, request) -&gt; str | None:\n        return request.COOKIES.get(\"api_version\")\n\n    def _from_user(self, request) -&gt; str | None:\n        if hasattr(request, 'user') and request.user.is_authenticated:\n            return getattr(request.user, 'api_version', None)\n        return None\n</code></pre>"},{"location":"advanced/operation-transformers/","title":"Operation Transformers","text":"<p>Schema transformers apply wherever a schema appears. Sometimes you need endpoint-specific logic that:</p> <ul> <li>Transforms both body and query parameters together</li> <li>Has different logic for the same schema on different endpoints</li> <li>Handles pagination, filtering, or other endpoint-specific structures</li> </ul> <p>Operation transformers give you full control over a specific endpoint's request or response.</p>"},{"location":"advanced/operation-transformers/#when-to-use-operation-transformers","title":"When to Use Operation Transformers","text":"<p>Use operation transformers when:</p> <ul> <li>The same schema needs different handling on different endpoints</li> <li>You need to transform query parameters alongside the body</li> <li>The response structure is endpoint-specific (pagination wrappers, etc.)</li> <li>Logic depends on the full request/response context</li> </ul> <p>Use schema transformers when:</p> <ul> <li>The transformation is the same everywhere the schema appears</li> <li>You're just adding/removing/renaming fields</li> </ul>"},{"location":"advanced/operation-transformers/#operationupgrade","title":"OperationUpgrade","text":"<p>Transform incoming requests for a specific endpoint. Receives both the body and query parameters:</p> <pre><code>from crane.data_migrations import OperationUpgrade, DataMigrationSet\n\ndef upgrade_search_users(\n    body: dict,\n    params: dict\n) -&gt; tuple[dict, dict]:\n    \"\"\"v1 \u2192 v2: Move 'role' from query param to request body.\"\"\"\n    if \"role\" in params:\n        role = params.pop(\"role\")\n        body[\"filters\"] = body.get(\"filters\", {})\n        body[\"filters\"][\"role\"] = role\n    return body, params\n\ndata_migrations = DataMigrationSet(\n    operation_upgrades=[\n        OperationUpgrade(\n            path=\"/users/search\",\n            method=\"post\",\n            transformer=upgrade_search_users,\n        ),\n    ],\n)\n</code></pre>"},{"location":"advanced/operation-transformers/#signature","title":"Signature","text":"<pre><code>def upgrade_transformer(\n    body: dict,          # Request body (empty dict if no body)\n    params: dict         # Query parameters\n) -&gt; tuple[dict, dict]:  # (new_body, new_params)\n    ...\n</code></pre>"},{"location":"advanced/operation-transformers/#operationdowngrade","title":"OperationDowngrade","text":"<p>Transform outgoing responses for a specific endpoint. Receives the response data and status code:</p> <pre><code>from crane.data_migrations import OperationDowngrade, DataMigrationSet\n\ndef downgrade_list_users(\n    data: dict,\n    status_code: int\n) -&gt; dict:\n    \"\"\"v2 \u2192 v1: Flatten paginated response.\"\"\"\n    # v2 returns: {\"items\": [...], \"total\": 100, \"page\": 1}\n    # v1 expected: [...]\n    if \"items\" in data:\n        return data[\"items\"]\n    return data\n\ndata_migrations = DataMigrationSet(\n    operation_downgrades=[\n        OperationDowngrade(\n            path=\"/users\",\n            method=\"get\",\n            transformer=downgrade_list_users,\n        ),\n    ],\n)\n</code></pre>"},{"location":"advanced/operation-transformers/#signature_1","title":"Signature","text":"<pre><code>def downgrade_transformer(\n    data: dict,         # Response body\n    status_code: int    # HTTP status code\n) -&gt; dict:              # Transformed response\n    ...\n</code></pre>"},{"location":"advanced/operation-transformers/#path-matching","title":"Path Matching","text":"<p>Operation transformers match by exact path and method:</p> <pre><code>OperationUpgrade(\n    path=\"/users/{user_id}\",  # Path with parameter placeholder\n    method=\"put\",             # HTTP method (lowercase)\n    transformer=...,\n)\n</code></pre> <p>The path should match the current API path (after any path rewrites).</p>"},{"location":"advanced/operation-transformers/#combining-with-schema-transformers","title":"Combining with Schema Transformers","text":"<p>Operation transformers run before schema transformers for requests, and after for responses:</p> <p>Request flow: <pre><code>v1 request\n    \u2192 OperationUpgrade (if defined)\n    \u2192 SchemaUpgrade (for each schema in body)\n    \u2192 endpoint\n</code></pre></p> <p>Response flow: <pre><code>endpoint\n    \u2192 SchemaDowngrade (for each schema in response)\n    \u2192 OperationDowngrade (if defined)\n    \u2192 v1 response\n</code></pre></p> <p>This means:</p> <ul> <li><code>OperationUpgrade</code> sees the old format, schema transformers see the result</li> <li><code>SchemaDowngrade</code> runs first, <code>OperationDowngrade</code> sees the already-transformed data</li> </ul>"},{"location":"advanced/operation-transformers/#async-transformers","title":"Async Transformers","text":"<p>Operation transformers can be async for database lookups or API calls:</p> <pre><code>async def upgrade_create_user(body: dict, params: dict) -&gt; tuple[dict, dict]:\n    \"\"\"Look up team ID from legacy team name.\"\"\"\n    if \"team_name\" in body:\n        team_name = body.pop(\"team_name\")\n        team = await Team.objects.aget(name=team_name)\n        body[\"team_id\"] = team.id\n    return body, params\n\nasync def downgrade_get_user(data: dict, status_code: int) -&gt; dict:\n    \"\"\"Add legacy fields for v1 clients.\"\"\"\n    if \"team_id\" in data:\n        team = await Team.objects.aget(id=data[\"team_id\"])\n        data[\"team_name\"] = team.name\n    return data\n</code></pre>"},{"location":"advanced/operation-transformers/#examples","title":"Examples","text":""},{"location":"advanced/operation-transformers/#pagination-change","title":"Pagination Change","text":"<p>v1 returned a flat list, v2 returns paginated:</p> <pre><code># v1: GET /items \u2192 [item1, item2, ...]\n# v2: GET /items \u2192 {\"items\": [...], \"total\": 100, \"next\": \"/items?page=2\"}\n\ndef downgrade_list_items(data: dict, status_code: int) -&gt; dict:\n    \"\"\"v2 \u2192 v1: Return just the items array.\"\"\"\n    if isinstance(data, dict) and \"items\" in data:\n        return data[\"items\"]\n    return data\n\ndef upgrade_list_items(body: dict, params: dict) -&gt; tuple[dict, dict]:\n    \"\"\"v1 \u2192 v2: Add default pagination params.\"\"\"\n    params.setdefault(\"page\", [\"1\"])\n    params.setdefault(\"page_size\", [\"20\"])\n    return body, params\n</code></pre>"},{"location":"advanced/operation-transformers/#parameter-restructuring","title":"Parameter Restructuring","text":"<p>v1 had flat query params, v2 uses nested filters:</p> <pre><code># v1: GET /users?name=alice&amp;role=admin\n# v2: GET /users?filters={\"name\":\"alice\",\"role\":\"admin\"}\n\nimport json\n\ndef upgrade_search_users(body: dict, params: dict) -&gt; tuple[dict, dict]:\n    \"\"\"v1 \u2192 v2: Nest filter params.\"\"\"\n    filters = {}\n    for key in [\"name\", \"role\", \"status\"]:\n        if key in params:\n            value = params.pop(key)\n            filters[key] = value[0] if isinstance(value, list) else value\n\n    if filters:\n        params[\"filters\"] = [json.dumps(filters)]\n\n    return body, params\n\ndef downgrade_search_users(body: dict, params: dict) -&gt; tuple[dict, dict]:\n    \"\"\"v2 \u2192 v1: Flatten filter params.\"\"\"\n    if \"filters\" in params:\n        filters_str = params.pop(\"filters\")\n        if isinstance(filters_str, list):\n            filters_str = filters_str[0]\n        filters = json.loads(filters_str)\n        for key, value in filters.items():\n            params[key] = [value]\n\n    return body, params\n</code></pre>"},{"location":"advanced/operation-transformers/#status-code-dependent-response","title":"Status Code Dependent Response","text":"<p>Different transformation based on success/error:</p> <pre><code>def downgrade_create_user(data: dict, status_code: int) -&gt; dict:\n    \"\"\"v2 \u2192 v1: Handle different response formats.\"\"\"\n    if status_code == 201:\n        # Success: remove new fields\n        data.pop(\"created_at\", None)\n        data.pop(\"updated_at\", None)\n    elif status_code &gt;= 400:\n        # Error: transform error format\n        # v2: {\"detail\": \"...\", \"code\": \"...\"}\n        # v1: {\"error\": \"...\"}\n        if \"detail\" in data:\n            return {\"error\": data[\"detail\"]}\n\n    return data\n</code></pre>"},{"location":"advanced/operation-transformers/#conditional-field-inclusion","title":"Conditional Field Inclusion","text":"<p>Include/exclude fields based on query params:</p> <pre><code>def downgrade_get_user(data: dict, status_code: int) -&gt; dict:\n    \"\"\"v2 \u2192 v1: Remove fields that didn't exist in v1.\"\"\"\n    # v1 didn't have detailed mode\n    data.pop(\"permissions\", None)\n    data.pop(\"activity_log\", None)\n    data.pop(\"settings\", None)\n    return data\n</code></pre>"},{"location":"advanced/operation-transformers/#multiple-operations","title":"Multiple Operations","text":"<p>You can have multiple operation transformers in the same migration:</p> <pre><code>data_migrations = DataMigrationSet(\n    operation_upgrades=[\n        OperationUpgrade(\"/users\", \"post\", upgrade_create_user),\n        OperationUpgrade(\"/users/search\", \"post\", upgrade_search_users),\n        OperationUpgrade(\"/users/{user_id}\", \"put\", upgrade_update_user),\n    ],\n    operation_downgrades=[\n        OperationDowngrade(\"/users\", \"get\", downgrade_list_users),\n        OperationDowngrade(\"/users/{user_id}\", \"get\", downgrade_get_user),\n    ],\n)\n</code></pre>"},{"location":"advanced/operation-transformers/#interaction-with-path-rewrites","title":"Interaction with Path Rewrites","text":"<p>If you have both a path rewrite and an operation transformer, use the new path in the transformer:</p> <pre><code>data_migrations = DataMigrationSet(\n    path_rewrites=[\n        PathRewrite(\n            old_path=\"/persons/{person_id}\",\n            new_path=\"/people/{person_id}\",\n        ),\n    ],\n    operation_downgrades=[\n        # Use the NEW path\n        OperationDowngrade(\"/people/{person_id}\", \"get\", downgrade_get_person),\n    ],\n)\n</code></pre> <p>The path rewrite happens first, then the operation transformer.</p>"},{"location":"advanced/operation-transformers/#testing","title":"Testing","text":"<pre><code>import pytest\n\ndef test_upgrade_search_users():\n    body = {}\n    params = {\"role\": [\"admin\"], \"name\": [\"alice\"]}\n\n    new_body, new_params = upgrade_search_users(body, params)\n\n    assert \"role\" not in new_params\n    assert new_body[\"filters\"][\"role\"] == \"admin\"\n\ndef test_downgrade_list_items():\n    data = {\"items\": [{\"id\": 1}, {\"id\": 2}], \"total\": 2}\n\n    result = downgrade_list_items(data, 200)\n\n    assert result == [{\"id\": 1}, {\"id\": 2}]\n</code></pre>"},{"location":"concepts/how-it-works/","title":"How It Works","text":"<p>django-ninja-crane enables API versioning through three mechanisms:</p> <ol> <li>Migration files store schema deltas between versions</li> <li>State reconstruction rebuilds the API schema at any historical version</li> <li>Runtime transformation converts data between versions on every request</li> </ol> <p>At Development time, you use <code>python manage.py makeapimigrations</code> to detect differences between the stored schema deltas and your code. Then, you fill in the generated migration file's transformers (if any), to tell the versioning middleware how to \"upgrade\" from this version to the latest version.</p> <p>Then, at Runtime, the migration files you made are used when a request for an older version is encountered:</p> <p></p>"},{"location":"concepts/how-it-works/#step-by-step","title":"Step by Step","text":"<ol> <li>Version extraction \u2014 The middleware reads <code>X-API-Version</code> header or <code>api_version</code> query param</li> <li>Upgrade loop \u2014 For each migration between extracted version and latest, apply upgrade transformers (path    rewrites, request body transforms)</li> <li>Endpoint execution \u2014 Your code runs with the latest format, unaware of versioning</li> <li>Downgrade loop \u2014 For each migration from latest back to extracted version, apply downgrade transformers (response    body transforms)</li> </ol>"},{"location":"concepts/how-it-works/#state-reconstruction","title":"State Reconstruction","text":"<p>Migrations store deltas, not full schemas. To get the API schema at version N, we apply all existing deltas:</p> <pre><code>empty \u2192 apply(m_0001) \u2192 v1 \u2192 apply(m_0002) \u2192 v2 \u2192 apply(m_0003) \u2192 v3\n</code></pre> <p>This allows our <code>makeapimigrations</code> command to compare the state resulting from all deltas against the state in your code. That difference can also be expressed as a version delta, and is what's saved into the newest migration file.</p> <p></p> <p>The state stored in the migration deltas does not cover all possible OpenAPI fields. To allow you to add examples, auth, ..., the runtime uses deltas backwards: It takes the openapi json currently generated by your NinjaAPI, and applies the inverse of each delta to get to the target version.</p>"},{"location":"concepts/how-it-works/#transformation-engine","title":"Transformation Engine","text":""},{"location":"concepts/how-it-works/#schema-transformers","title":"Schema Transformers","text":"<p>Schema transformers apply recursively wherever a schema appears:</p> <pre><code># PersonOut might appear in:\n# - Direct response body\n# - Nested in TeamOut.leader\n# - Items in list[PersonOut]\n# - Union types: PersonOut | CompanyOut\n</code></pre> <p>The engine traverses the response structure and applies the appropriate transformer at each location.</p>"},{"location":"concepts/how-it-works/#transformation-order","title":"Transformation Order","text":"<p>For a request from v1 to a v3 API:</p> <pre><code>v1 request \u2192 upgrade(m_0002) \u2192 upgrade(m_0003) \u2192 v3 endpoint\nv3 response \u2192 downgrade(m_0003) \u2192 downgrade(m_0002) \u2192 v1 response\n</code></pre> <p>Migrations are applied in sequence, forwards for upgrades, backwards for downgrades.</p> <p>This allows each transformer to be written in isolation: it only needs to concern itself how to get a schema from version n to version n+1, and back.</p>"},{"location":"concepts/how-it-works/#middleware-details","title":"Middleware Details","text":"<p>The <code>VersionedAPIMiddleware</code>:</p> <ol> <li>Discovers APIs \u2014 Finds all <code>VersionedNinjaAPI</code> instances by introspecting URL patterns</li> <li>Caches migrations \u2014 Loads migrations once, caches API states</li> <li>Handles async \u2014 Supports both sync and async Django</li> <li>Preserves headers \u2014 Copies response headers through transformations</li> </ol>"},{"location":"concepts/how-it-works/#per-request-state","title":"Per-Request State","text":"<p>The middleware attaches version info to the request:</p> <pre><code>request.api_version  # \"1\" - the resolved version\nrequest.api_latest_version  # \"3\" - the current latest\nrequest.original_path  # \"/persons/1\" - before rewriting (if rewritten)\n</code></pre>"},{"location":"concepts/how-it-works/#openapi-generation","title":"OpenAPI Generation","text":"<p>The versioned OpenAPI generator:</p> <ol> <li>Loads migrations up to the requested version</li> <li>Reconstructs the API state at that version</li> <li>Generates an OpenAPI schema reflecting that state</li> </ol> <p>This means <code>/api/docs?version=1</code> shows the API as it was at v1, with old paths, old schemas, and old parameters.</p> Why Deltas Instead of Full Schemas? <p>Storing full schemas at each version would be simpler, but result in much larger migration files:</p> <ul> <li>Most changes are small (add a field, rename an endpoint)</li> <li>Storing the json of each state would also include all the json schema data for unchanged endpoints and schemas.</li> <li>Deltas make diffs obvious and reviewable</li> </ul> <p>The tradeoff is that reconstructing state requires applying all migrations in sequence. This is cached in production, so the cost is paid once per process startup.</p>"},{"location":"concepts/migration-files/","title":"Migration Files","text":"<p>Migration files are Python modules that record how your API changed between versions. They serve two purposes:</p> <ol> <li>Schema deltas \u2014 What operations and schemas were added, removed, or modified</li> <li>Data migrations \u2014 How to transform data between the old and new formats</li> </ol>"},{"location":"concepts/migration-files/#file-structure","title":"File Structure","text":"<p>Migration files follow this naming pattern:</p> <pre><code>m_{sequence}_{slug}.py\n</code></pre> <p>For example: <code>m_0001_initial_api.py</code>, <code>m_0002_add_phone_field.py</code></p>"},{"location":"concepts/migration-files/#anatomy-of-a-migration-file","title":"Anatomy of a Migration File","text":"<p>Here's a complete migration file:</p> <pre><code>\"\"\"\nAPI migration: 1 -&gt; 2\n\nAdd phone field to PersonOut schema\n\"\"\"\nfrom crane.delta import VersionDelta\nfrom crane.data_migrations import (\n    DataMigrationSet,\n    SchemaDowngrade,\n    SchemaUpgrade,\n)\n\n# Dependencies on previous migrations\ndependencies: list[tuple[str, str]] = [(\"myapp.api_migrations.default\", \"1\")]\n\n# Version transition\nfrom_version: str | None = \"1\"\nto_version: str = \"2\"\n\n# Schema delta (auto-generated)\ndelta = VersionDelta.model_validate_json(\"\"\"\n{\n    \"actions\": [\n        {\n            \"action\": \"schema_definition_modified\",\n            \"schema_ref\": \"#/components/schemas/PersonOut\",\n            \"old_schema\": {\n                \"properties\": {\n                    \"name\": {\"type\": \"string\"}\n                },\n                \"required\": [\"name\"]\n            },\n            \"new_schema\": {\n                \"properties\": {\n                    \"name\": {\"type\": \"string\"},\n                    \"phone\": {\"type\": \"string\"}\n                },\n                \"required\": [\"name\"]\n            }\n        }\n    ]\n}\n\"\"\")\n\n\n# Data transformers (you implement these)\ndef downgrade_person_out(data: dict) -&gt; dict:\n    \"\"\"2 -&gt; 1: Remove phone for v1 clients.\"\"\"\n    data.pop(\"phone\", None)\n    return data\n\n\ndef upgrade_person_out(data: dict) -&gt; dict:\n    \"\"\"1 -&gt; 2: Add default phone for v1 requests.\"\"\"\n    data.setdefault(\"phone\", None)\n    return data\n\n\ndata_migrations = DataMigrationSet(\n    schema_downgrades=[\n        SchemaDowngrade(\"#/components/schemas/PersonOut\", downgrade_person_out),\n    ],\n    schema_upgrades=[\n        SchemaUpgrade(\"#/components/schemas/PersonOut\", upgrade_person_out),\n    ],\n)\n</code></pre>"},{"location":"concepts/migration-files/#required-attributes","title":"Required Attributes","text":""},{"location":"concepts/migration-files/#dependencies","title":"<code>dependencies</code>","text":"<p>A list of <code>(module_path, version)</code> tuples that this migration depends on:</p> <pre><code>dependencies: list[tuple[str, str]] = [(\"myapp.api_migrations.default\", \"1\")]\n</code></pre> <p>The first migration has an empty list. Subsequent migrations depend on the previous version. Currently unused, but tracked to later allow merge api migrations, similar to <code>python manage.py makemigrations --merge</code>.</p>"},{"location":"concepts/migration-files/#from_version-and-to_version","title":"<code>from_version</code> and <code>to_version</code>","text":"<p>The version transition this migration represents:</p> <pre><code>from_version: str | None = \"1\"  # None for initial migration - \nto_version: str = \"2\"\n</code></pre>"},{"location":"concepts/migration-files/#delta","title":"<code>delta</code>","text":"<p>A <code>VersionDelta</code> object containing all schema changes. This is auto-generated by <code>makeapimigrations</code> and shouldn't be edited manually:</p> <pre><code>delta = VersionDelta.model_validate_json(\"\"\"{ ... }\"\"\")\n</code></pre>"},{"location":"concepts/migration-files/#delta-actions","title":"Delta Actions","text":"<p>The <code>delta.actions</code> list contains these action types:</p>"},{"location":"concepts/migration-files/#operation-changes","title":"Operation Changes","text":"Action Description <code>operation_added</code> New endpoint added <code>operation_removed</code> Endpoint deleted <code>operation_modified</code> Endpoint parameters or responses changed"},{"location":"concepts/migration-files/#schema-changes","title":"Schema Changes","text":"Action Description <code>schema_definition_added</code> New schema type added <code>schema_definition_removed</code> Schema type deleted <code>schema_definition_modified</code> Schema fields or types changed"},{"location":"concepts/migration-files/#data-migrations","title":"Data Migrations","text":"<p>The <code>data_migrations</code> object contains transformers for runtime data conversion.</p> <p>Note</p> <p>You'll usually not have to write any of the transformers described below. In most cases they are automatically generated by the <code>makeapimigrations</code> command and created in your migrations file.</p> <p>The documentation below is if you ever have a case you need to manually describe in your migration files, and so you can read and understand the contents of a migration file, to check if the auto generated logic is as you'd expect.</p>"},{"location":"concepts/migration-files/#schema-transformers","title":"Schema Transformers","text":"<p>Schema transformers apply wherever that schema appears\u2014in responses, nested objects, or array items:</p> <pre><code>data_migrations = DataMigrationSet(\n    schema_downgrades=[\n        # Applied to responses when downgrading (new \u2192 old)\n        SchemaDowngrade(\"#/components/schemas/PersonOut\", downgrade_person),\n    ],\n    schema_upgrades=[\n        # Applied to requests when upgrading (old \u2192 new)\n        SchemaUpgrade(\"#/components/schemas/PersonIn\", upgrade_person),\n    ],\n)\n</code></pre>"},{"location":"concepts/migration-files/#path-rewrites","title":"Path Rewrites","text":"<p>When an endpoint URL changes, the migration generator will add a path rewrite:</p> <pre><code>from crane.data_migrations import PathRewrite\n\ndata_migrations = DataMigrationSet(\n    path_rewrites=[\n        PathRewrite(\n            old_path=\"/persons/{person_id}\",\n            new_path=\"/people/{person_id}\",\n            methods=[\"get\", \"put\", \"delete\"],\n        ),\n    ],\n)\n</code></pre>"},{"location":"concepts/migration-files/#operation-transformers","title":"Operation Transformers","text":"<p>For endpoint-specific transformations that can't be expressed at the schema level:</p> <pre><code>from crane.data_migrations import OperationUpgrade, OperationDowngrade\n\ndata_migrations = DataMigrationSet(\n    operation_upgrades=[\n        OperationUpgrade(\"/users\", \"post\", upgrade_create_user),\n    ],\n    operation_downgrades=[\n        OperationDowngrade(\"/users\", \"get\", downgrade_list_users),\n    ],\n)\n</code></pre> <p>See Operation Transformers for details.</p>"},{"location":"concepts/migration-files/#transformer-functions","title":"Transformer Functions","text":""},{"location":"concepts/migration-files/#downgrade-transformers","title":"Downgrade Transformers","text":"<p>Convert response data from the new schema to the old schema:</p> <pre><code>def downgrade_person_out(data: dict) -&gt; dict:\n    \"\"\"Remove fields that didn't exist in the old version.\"\"\"\n    data.pop(\"phone\", None)  # phone was added in this version\n    return data\n</code></pre> <p>Tip</p> <p>The downgrade function receives data in the new format and must return data in the old format. That means you need to consider how to transform this schema if it is used in a response body.</p>"},{"location":"concepts/migration-files/#upgrade-transformers","title":"Upgrade Transformers","text":"<p>Convert request data from the old schema to the new schema:</p> <pre><code>def upgrade_person_in(data: dict) -&gt; dict:\n    \"\"\"Add fields with defaults for old clients.\"\"\"\n    data.setdefault(\"phone\", None)  # provide default for new field\n    return data\n</code></pre> <p>Tip</p> <p>The upgrade function receives data in the old format and must return data in the new format. That means you need to consider how to transform this schema if it is used in a request body</p>"},{"location":"concepts/migration-files/#async-transformers","title":"Async Transformers","text":"<p>Transformers can be sync or async, according to your preference.</p> <pre><code>async def upgrade_person_in(data: dict) -&gt; dict:\n    if \"legacy_id\" in data:\n        # Look up the new ID\n        new_id = await lookup_new_id(data.pop(\"legacy_id\"))\n        data[\"id\"] = new_id\n    return data\n</code></pre> <p>Async is slightly better performance</p> <p>The middleware itself is written to support async operation, and wraps non-coroutine transformers in a <code>sync_to_async</code> call to make sure the event loop is not blocked by blocking I/O, if any. That does mean there's a small (creating a thread) overhead to sync transformers.</p> <p>If you want the best performance, write your transformers async. If you're not familiar (enough) with async python, it's still fine to write them sync. I won't judge, hell, it's the default option.</p>"},{"location":"concepts/migration-files/#schema-references","title":"Schema References","text":"<p>Schema references use the OpenAPI JSON pointer format:</p> <pre><code>#/components/schemas/PersonOut\n</code></pre> <p>This matches the schema name in your Django Ninja schemas:</p> <pre><code>class PersonOut(Schema):  # \u2192 #/components/schemas/PersonOut\n    name: str\n</code></pre>"},{"location":"concepts/migration-files/#generation-vs-manual-editing","title":"Generation vs Manual Editing","text":"<p>The <code>delta</code> is auto-generated and shouldn't be edited. The <code>data_migrations</code> require manual implementation\u2014the generator creates skeleton functions with <code>NotImplementedError</code> for breaking changes.</p> <p>Warning</p> <p>Don't edit the <code>delta</code> JSON manually. If you need to change what's tracked, modify your API and regenerate.</p>"},{"location":"concepts/migration-files/#migration-chain","title":"Migration Chain","text":"<p>Migrations form a chain through their dependencies. When reconstructing API state at a version, crane applies migrations in sequence:</p> <pre><code>empty \u2192 m_0001 (v1) \u2192 m_0002 (v2) \u2192 m_0003 (v3)\n</code></pre> <p>To get the API schema at v2, crane applies <code>m_0001</code> and <code>m_0002</code> but not <code>m_0003</code>.</p>"},{"location":"concepts/migration-files/#next-steps","title":"Next Steps","text":"<ul> <li>Modifying a Schema \u2014 Step-by-step example</li> <li>Path Rewrites \u2014 Handle URL changes</li> <li>Operation Transformers \u2014 Advanced transformation patterns</li> </ul>"},{"location":"examples/modifying-schema/","title":"Schema Transformation Patterns","text":"<p>This guide covers common schema changes and the transformers needed to maintain backwards compatibility.</p>"},{"location":"examples/modifying-schema/#how-schema-transformers-work","title":"How Schema Transformers Work","text":"<p>When a client uses an older API version:</p> <ul> <li>Requests are upgraded: old format \u2192 new format (before your endpoint runs)</li> <li>Responses are downgraded: new format \u2192 old format (after your endpoint returns)</li> </ul> <p>Schema transformers apply automatically wherever the schema appears\u2014direct responses, nested objects, or items in arrays.</p> <pre><code>from crane.data_migrations import (\n    DataMigrationSet,\n    SchemaDowngrade,\n    SchemaUpgrade,\n)\n\ndata_migrations = DataMigrationSet(\n    schema_downgrades=[\n        SchemaDowngrade(\"#/components/schemas/PersonOut\", downgrade_person_out),\n    ],\n    schema_upgrades=[\n        SchemaUpgrade(\"#/components/schemas/PersonIn\", upgrade_person_in),\n    ],\n)\n</code></pre>"},{"location":"examples/modifying-schema/#common-patterns","title":"Common Patterns","text":""},{"location":"examples/modifying-schema/#rename-a-field","title":"Rename a Field","text":"<pre><code># v1: firstName\n# v2: first_name\n\ndef downgrade_person(data: dict) -&gt; dict:\n    if \"first_name\" in data:\n        data[\"firstName\"] = data.pop(\"first_name\")\n    return data\n\ndef upgrade_person(data: dict) -&gt; dict:\n    if \"firstName\" in data:\n        data[\"first_name\"] = data.pop(\"firstName\")\n    return data\n</code></pre>"},{"location":"examples/modifying-schema/#add-a-new-field","title":"Add a New Field","text":"<pre><code># v1: no is_active field\n# v2: is_active: bool\n\ndef downgrade_person(data: dict) -&gt; dict:\n    data.pop(\"is_active\", None)\n    return data\n\ndef upgrade_person(data: dict) -&gt; dict:\n    data.setdefault(\"is_active\", True)\n    return data\n</code></pre>"},{"location":"examples/modifying-schema/#remove-a-field","title":"Remove a Field","text":"<pre><code># v1: has legacy_id\n# v2: legacy_id removed\n\ndef downgrade_person(data: dict) -&gt; dict:\n    data[\"legacy_id\"] = data.get(\"id\")  # Reconstruct from other data\n    return data\n\ndef upgrade_person(data: dict) -&gt; dict:\n    data.pop(\"legacy_id\", None)\n    return data\n</code></pre>"},{"location":"examples/modifying-schema/#change-field-type","title":"Change Field Type","text":"<pre><code># v1: age as string \"25\"\n# v2: age as integer 25\n\ndef downgrade_person(data: dict) -&gt; dict:\n    if \"age\" in data:\n        data[\"age\"] = str(data[\"age\"])\n    return data\n\ndef upgrade_person(data: dict) -&gt; dict:\n    if \"age\" in data:\n        data[\"age\"] = int(data[\"age\"])\n    return data\n</code></pre>"},{"location":"examples/modifying-schema/#single-value-to-list","title":"Single Value to List","text":"<pre><code># v1: email: str\n# v2: emails: list[str]\n\ndef downgrade_person(data: dict) -&gt; dict:\n    emails = data.pop(\"emails\", [])\n    data[\"email\"] = emails[0] if emails else \"\"\n    return data\n\ndef upgrade_person(data: dict) -&gt; dict:\n    email = data.pop(\"email\", None)\n    data[\"emails\"] = [email] if email else []\n    return data\n</code></pre> <p>Note</p> <p>Downgrading loses data (additional emails beyond the first). This is often acceptable since v1 clients can't handle multiple values anyway.</p>"},{"location":"examples/modifying-schema/#optional-to-required","title":"Optional to Required","text":"<pre><code># v1: phone: str | None = None\n# v2: phone: str (required)\n\ndef downgrade_person(data: dict) -&gt; dict:\n    # v2 always has phone, nothing to do\n    return data\n\ndef upgrade_person(data: dict) -&gt; dict:\n    data.setdefault(\"phone\", \"\")  # Provide default for old clients\n    return data\n</code></pre>"},{"location":"examples/modifying-schema/#required-to-optional","title":"Required to Optional","text":"<pre><code># v1: phone: str (required)\n# v2: phone: str | None = None\n\ndef downgrade_person(data: dict) -&gt; dict:\n    if data.get(\"phone\") is None:\n        data[\"phone\"] = \"\"  # Old schema required this field\n    return data\n\ndef upgrade_person(data: dict) -&gt; dict:\n    # v1 always has phone, nothing to do\n    return data\n</code></pre>"},{"location":"examples/modifying-schema/#nested-object-change","title":"Nested Object Change","text":"<pre><code># v1: address: str (flat string)\n# v2: address: {street: str, city: str, zip: str}\n\ndef downgrade_person(data: dict) -&gt; dict:\n    address = data.get(\"address\", {})\n    if isinstance(address, dict):\n        parts = [address.get(\"street\", \"\"), address.get(\"city\", \"\"), address.get(\"zip\", \"\")]\n        data[\"address\"] = \", \".join(p for p in parts if p)\n    return data\n\ndef upgrade_person(data: dict) -&gt; dict:\n    address = data.get(\"address\", \"\")\n    if isinstance(address, str):\n        data[\"address\"] = {\"street\": address, \"city\": \"\", \"zip\": \"\"}\n    return data\n</code></pre>"},{"location":"examples/modifying-schema/#enum-value-change","title":"Enum Value Change","text":"<pre><code># v1: status in [\"active\", \"inactive\"]\n# v2: status in [\"active\", \"inactive\", \"pending\"]\n\ndef downgrade_person(data: dict) -&gt; dict:\n    if data.get(\"status\") == \"pending\":\n        data[\"status\"] = \"inactive\"  # Map new value to closest old value\n    return data\n\ndef upgrade_person(data: dict) -&gt; dict:\n    # Old values still valid, nothing to do\n    return data\n</code></pre>"},{"location":"examples/modifying-schema/#split-a-field","title":"Split a Field","text":"<pre><code># v1: name: str (full name)\n# v2: first_name: str, last_name: str\n\ndef downgrade_person(data: dict) -&gt; dict:\n    first = data.pop(\"first_name\", \"\")\n    last = data.pop(\"last_name\", \"\")\n    data[\"name\"] = f\"{first} {last}\".strip()\n    return data\n\ndef upgrade_person(data: dict) -&gt; dict:\n    name = data.pop(\"name\", \"\")\n    parts = name.split(\" \", 1)\n    data[\"first_name\"] = parts[0] if parts else \"\"\n    data[\"last_name\"] = parts[1] if len(parts) &gt; 1 else \"\"\n    return data\n</code></pre>"},{"location":"examples/modifying-schema/#merge-fields","title":"Merge Fields","text":"<pre><code># v1: first_name: str, last_name: str\n# v2: full_name: str\n\ndef downgrade_person(data: dict) -&gt; dict:\n    full_name = data.pop(\"full_name\", \"\")\n    parts = full_name.split(\" \", 1)\n    data[\"first_name\"] = parts[0] if parts else \"\"\n    data[\"last_name\"] = parts[1] if len(parts) &gt; 1 else \"\"\n    return data\n\ndef upgrade_person(data: dict) -&gt; dict:\n    first = data.pop(\"first_name\", \"\")\n    last = data.pop(\"last_name\", \"\")\n    data[\"full_name\"] = f\"{first} {last}\".strip()\n    return data\n</code></pre>"},{"location":"examples/modifying-schema/#handling-nested-schemas","title":"Handling Nested Schemas","text":"<p>Schema transformers apply recursively. If <code>PersonOut</code> is nested inside another schema, the transformer applies automatically:</p> <pre><code>class TeamOut(Schema):\n    name: str\n    members: list[PersonOut]  # PersonOut transformer applies to each member\n</code></pre>"},{"location":"examples/modifying-schema/#bidirectional-transformers","title":"Bidirectional Transformers","text":"<p>For schemas used in both requests and responses (like when the same schema is returned after creation), you typically need both upgrade and downgrade transformers:</p> <pre><code>data_migrations = DataMigrationSet(\n    schema_downgrades=[\n        SchemaDowngrade(\"#/components/schemas/PersonOut\", downgrade_person),\n        SchemaDowngrade(\"#/components/schemas/PersonIn\", downgrade_person),  # Same logic\n    ],\n    schema_upgrades=[\n        SchemaUpgrade(\"#/components/schemas/PersonOut\", upgrade_person),\n        SchemaUpgrade(\"#/components/schemas/PersonIn\", upgrade_person),\n    ],\n)\n</code></pre>"},{"location":"examples/modifying-schema/#when-schema-transformers-arent-enough","title":"When Schema Transformers Aren't Enough","text":"<p>Use Operation Transformers when you need:</p> <ul> <li>Access to both body and query parameters together</li> <li>Different logic based on HTTP status code</li> <li>Endpoint-specific transformations that don't apply globally</li> </ul>"},{"location":"examples/path-rewrites/","title":"Path Rewrites","text":"<p>When you rename an endpoint's URL path, you need to rewrite requests from old clients so they reach the new endpoint. Path rewrites handle this transparently.</p>"},{"location":"examples/path-rewrites/#when-to-use-path-rewrites","title":"When to Use Path Rewrites","text":"<ul> <li>Renaming a resource: <code>/persons</code> \u2192 <code>/people</code></li> <li>Restructuring URLs: <code>/users/{id}/posts</code> \u2192 <code>/posts?user_id={id}</code></li> <li>Fixing inconsistent naming: <code>/getUser</code> \u2192 <code>/users/{id}</code></li> </ul>"},{"location":"examples/path-rewrites/#basic-example","title":"Basic Example","text":"<p>You're renaming <code>/persons/{person_id}</code> to <code>/people/{person_id}</code>:</p> <pre><code># Old (v1)\n@router.get(\"/persons/{person_id}\", response=PersonOut)\ndef get_person(request, person_id: int):\n    return Person.objects.get(id=person_id)\n\n\n# New (v2)\n@router.get(\"/people/{person_id}\", response=PersonOut)\ndef get_person(request, person_id: int):\n    return Person.objects.get(id=person_id)\n</code></pre>"},{"location":"examples/path-rewrites/#generate-the-migration","title":"Generate the Migration","text":"<pre><code>python manage.py makeapimigrations \\\n    --label default \\\n    --app myapp \\\n    --name \"Rename persons to people\"\n</code></pre> <p>The migration will detect that an operation was removed (<code>/persons/{person_id}</code>) and added (<code>/people/{person_id}</code>) with the same <code>operation_id</code>. It auto-generates a <code>PathRewrite</code>:</p> <pre><code>data_migrations = DataMigrationSet(\n    path_rewrites=[\n        PathRewrite(\n            old_path=\"/persons/{person_id}\",\n            new_path=\"/people/{person_id}\",\n            methods=[\"get\"],\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/path-rewrites/#how-it-works","title":"How It Works","text":"<p>When a v1 client requests:</p> <pre><code>GET /api/persons/123\nX-API-Version: 1\n</code></pre> <p>The middleware:</p> <ol> <li>Detects v1 request</li> <li>Rewrites path to <code>/api/people/123</code></li> <li>Routes to the new endpoint</li> <li>Returns the response (applying any schema transformers)</li> </ol> <p>The client never sees the path change.</p>"},{"location":"examples/path-rewrites/#path-parameters","title":"Path Parameters","text":"<p>Path parameters use <code>{name}</code> syntax. Parameter values are preserved during rewriting:</p> <pre><code>PathRewrite(\n    old_path=\"/persons/{person_id}\",\n    new_path=\"/people/{person_id}\",\n)\n</code></pre> <p>Request <code>/persons/42</code> \u2192 <code>/people/42</code></p>"},{"location":"examples/path-rewrites/#parameter-renaming","title":"Parameter Renaming","text":"<p>You can rename parameters by using different names:</p> <pre><code>PathRewrite(\n    old_path=\"/users/{user_id}\",\n    new_path=\"/users/{id}\",  # parameter renamed\n)\n</code></pre> <p>The value is transferred to the new parameter name.</p>"},{"location":"examples/path-rewrites/#method-specific-rewrites","title":"Method-Specific Rewrites","text":"<p>By default, a <code>PathRewrite</code> applies to all HTTP methods. Use <code>methods</code> to restrict:</p> <pre><code># Only rewrite GET requests\nPathRewrite(\n    old_path=\"/persons/{person_id}\",\n    new_path=\"/people/{person_id}\",\n    methods=[\"get\"],\n)\n\n# Rewrite GET, PUT, DELETE but not POST\nPathRewrite(\n    old_path=\"/persons/{person_id}\",\n    new_path=\"/people/{person_id}\",\n    methods=[\"get\", \"put\", \"delete\"],\n)\n</code></pre>"},{"location":"examples/path-rewrites/#multiple-rewrites","title":"Multiple Rewrites","text":"<p>You can have multiple path rewrites in a single migration:</p> <pre><code>data_migrations = DataMigrationSet(\n    path_rewrites=[\n        PathRewrite(\n            old_path=\"/persons\",\n            new_path=\"/people\",\n            methods=[\"get\", \"post\"],\n        ),\n        PathRewrite(\n            old_path=\"/persons/{person_id}\",\n            new_path=\"/people/{person_id}\",\n            methods=[\"get\", \"put\", \"delete\"],\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/path-rewrites/#combining-with-schema-changes","title":"Combining with Schema Changes","text":"<p>Path rewrites often accompany schema changes. The same migration can have both:</p> <pre><code>data_migrations = DataMigrationSet(\n    path_rewrites=[\n        PathRewrite(\n            old_path=\"/persons/{person_id}\",\n            new_path=\"/people/{person_id}\",\n        ),\n    ],\n    schema_downgrades=[\n        SchemaDowngrade(\"#/components/schemas/PersonOut\", downgrade_person),\n    ],\n    schema_upgrades=[\n        SchemaUpgrade(\"#/components/schemas/PersonIn\", upgrade_person),\n    ],\n)\n</code></pre> <p>Order of operations:</p> <ol> <li>Path rewrite (request URL modified)</li> <li>Request upgrade (body transformed)</li> <li>Endpoint called</li> <li>Response downgrade (body transformed back)</li> </ol>"},{"location":"examples/path-rewrites/#automatic-detection","title":"Automatic Detection","text":"<p>The migration generator detects path renames automatically by matching:</p> <ul> <li>Same <code>operation_id</code> (the function name by default)</li> <li>Same HTTP method</li> <li>Different paths</li> </ul> <p>If your rename isn't detected, ensure the endpoint function name stayed the same.</p>"},{"location":"examples/path-rewrites/#manual-path-rewrites","title":"Manual Path Rewrites","text":"<p>For complex restructuring that isn't auto-detected, add rewrites manually:</p> <pre><code># Complex restructure: nested resource to query param\n# /users/{user_id}/posts \u2192 /posts?user_id={user_id}\n\ndata_migrations = DataMigrationSet(\n    path_rewrites=[\n        PathRewrite(\n            old_path=\"/users/{user_id}/posts\",\n            new_path=\"/posts\",\n            methods=[\"get\"],\n        ),\n    ],\n    operation_upgrades=[\n        # Also need to transform the request to add query param\n        OperationUpgrade(\"/posts\", \"get\", add_user_id_param),\n    ],\n)\n\n\ndef add_user_id_param(body: dict, params: dict) -&gt; tuple[dict, dict]:\n    \"\"\"Extract user_id from the original path and add as query param.\"\"\"\n    # The middleware captures path params before rewrite\n    if \"user_id\" in params:\n        # Already handled\n        pass\n    return body, params\n</code></pre> <p>Note</p> <p>For complex path restructuring, you may need both a <code>PathRewrite</code> and an <code>OperationUpgrade</code> to handle parameter movement.</p>"},{"location":"examples/path-rewrites/#versioned-openapi-docs","title":"Versioned OpenAPI Docs","text":"<p>An easy way to validate whether your path rewrites are successfully written in your migration, is by checking the OpenAPI docs for your NinjaAPI.</p> <p>The versioned OpenAPI schema shows the paths as they existed at each version:</p> <ul> <li>V1 docs show <code>/persons/{person_id}</code></li> <li>V2 docs show <code>/people/{person_id}</code></li> </ul> <p>Clients using the v1 docs will use the old paths, which get rewritten.</p>"},{"location":"examples/path-rewrites/#limitations","title":"Limitations","text":"<p>Path rewrites work for simple URL structure changes. They don't support:</p> <ul> <li>Query parameter to path conversion (<code>/items?id=1</code> \u2192 <code>/items/1</code>)</li> <li>Complex routing logic (use operation transformers instead)</li> <li>Removing path segments (<code>/api/v1/items</code> \u2192 <code>/items</code>)</li> </ul> <p>For these cases, use Operation Transformers with custom logic.</p>"},{"location":"examples/path-rewrites/#next-steps","title":"Next Steps","text":"<ul> <li>Modifying a Schema \u2014 Schema transformation examples</li> <li>Operation Transformers \u2014 Endpoint-specific logic</li> <li>Migration Files \u2014 Full file format reference</li> </ul>"},{"location":"get-started/configuration/","title":"Configuration Reference","text":"<p>Reference for configuring django-ninja-crane.</p>"},{"location":"get-started/configuration/#versionedninjaapi","title":"VersionedNinjaAPI","text":"<p>All standard <code>NinjaAPI</code> parameters (like <code>auth</code>, <code>csrf</code>, <code>title</code>, etc.) are also supported.</p>"},{"location":"get-started/configuration/#crane.VersionedNinjaAPI","title":"crane.VersionedNinjaAPI","text":"<pre><code>VersionedNinjaAPI(\n    *,\n    api_label: str,\n    app_label: str | None = None,\n    versioning: VersioningSystem = \"numerical\",\n    url_prefix: str | None = None,\n    version_header: str = \"X-API-Version\",\n    default_version: str = \"latest\",\n    docs: DocsBase = VersionedSwagger(),\n    **kwargs: Any,\n)\n</code></pre> <p>NinjaAPI subclass with built-in API versioning and migration support.</p> Example usage <pre><code>api = VersionedNinjaAPI(api_label=\"default\")\napi.add_router(\"/persons\", persons_router)\n\nurlpatterns = [\n    path(\"api/\", api.urls),\n]\n</code></pre> <p>Initialize a versioned API.</p> <p>Parameters:</p> Name Type Description Default <code>api_label</code> <code>str</code> <p>Unique identifier for this API within its app.</p> required <code>app_label</code> <code>str | None</code> <p>Django app label. Auto-detected if not provided.</p> <code>None</code> <code>versioning</code> <code>VersioningSystem</code> <p>Version naming scheme - \"numerical\" (1, 2, 3...), \"date\" (YYYY-MM-DD), or \"manual\" (user specifies).</p> <code>'numerical'</code> <code>url_prefix</code> <code>str | None</code> <p>URL prefix where this API is mounted. Auto-detected if not provided.</p> <code>None</code> <code>version_header</code> <code>str</code> <p>HTTP header name for version specification.</p> <code>'X-API-Version'</code> <code>default_version</code> <code>str</code> <p>Default version when none specified (\"latest\" or specific version).</p> <code>'latest'</code> <code>docs</code> <code>DocsBase</code> <p>Docs renderer. Defaults to VersionedSwagger() with version selector.</p> <code>VersionedSwagger()</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to NinjaAPI.</p> <code>{}</code>"},{"location":"get-started/configuration/#version-naming-schemes","title":"Version Naming Schemes","text":"<p>The <code>versioning</code> parameter controls how version names are generated:</p> <pre><code># Numerical: 1, 2, 3, ...\napi = VersionedNinjaAPI(api_label=\"default\", versioning=\"numerical\")\n\n# Date-based: 2024-01-15, 2024-02-20, ...\napi = VersionedNinjaAPI(api_label=\"default\", versioning=\"date\")\n\n# Manual: You specify the version name each time\napi = VersionedNinjaAPI(api_label=\"default\", versioning=\"manual\")\n</code></pre>"},{"location":"get-started/configuration/#multiple-apis","title":"Multiple APIs","text":"<p>You can have multiple versioned APIs in the same project:</p> <pre><code># Public API\npublic_api = VersionedNinjaAPI(\n    api_label=\"public\",\n    app_label=\"myapp\",\n    version_header=\"X-Public-API-Version\",\n)\n\n# Admin API\nadmin_api = VersionedNinjaAPI(\n    api_label=\"admin\",\n    app_label=\"myapp\",\n    version_header=\"X-Admin-API-Version\",\n)\n\nurlpatterns = [\n    path(\"api/v1/\", public_api.urls),\n    path(\"admin-api/\", admin_api.urls),\n]\n</code></pre> <p>Each API maintains its own migration chain in separate directories:</p> <ul> <li><code>myapp/api_migrations/public/</code></li> <li><code>myapp/api_migrations/admin/</code></li> </ul>"},{"location":"get-started/configuration/#migration-directory-structure","title":"Migration Directory Structure","text":"<p>Migrations are stored in your app's <code>api_migrations</code> directory, organized by API label:</p> <pre><code>myapp/\n\u251c\u2500\u2500 api_migrations/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 default/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 m_0001_initial_api.py\n\u2502       \u2514\u2500\u2500 m_0002_add_phone_field.py\n\u251c\u2500\u2500 api.py\n\u2514\u2500\u2500 models.py\n</code></pre> <p>The directory structure is created automatically when you run <code>makeapimigrations</code> for the first time.</p>"},{"location":"get-started/configuration/#version-detection","title":"Version Detection","text":"<p>Clients specify which API version they want using the HTTP header:</p> <pre><code>X-API-Version: 1\n</code></pre> <p>If no version is specified, the <code>default_version</code> is used (typically <code>\"latest\"</code>).</p> <p>For custom version detection logic (subdomains, cookies, URL paths), see Custom Version Resolver.</p>"},{"location":"get-started/quickstart/","title":"Quickstart","text":"<p>This guide walks you through setting up API versioning in an existing Django Ninja project. By the end, you'll have a versioned API that serves different schema versions to different clients.</p>"},{"location":"get-started/quickstart/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.12+</li> <li>Django 6.0+</li> <li>Django Ninja 1.5+</li> <li>An existing Django Ninja API</li> </ul>"},{"location":"get-started/quickstart/#install-django-ninja-crane","title":"Install django-ninja-crane","text":"<pre><code>pip install django-ninja-crane\n</code></pre>"},{"location":"get-started/quickstart/#configure-django","title":"Configure Django","text":"<p>Add the middleware to your <code>settings.py</code>:</p> <pre><code>MIDDLEWARE = [\n    # ... other middleware ...\n    \"crane.middleware.VersionedAPIMiddleware\",\n]\n\nINSTALLED_APPS = [\n    # ...\n    \"crane\",\n]\n</code></pre>"},{"location":"get-started/quickstart/#use-versionedninjaapi","title":"Use VersionedNinjaAPI","text":"<p>Replace your <code>NinjaAPI</code> instance with <code>VersionedNinjaAPI</code>:</p> <pre><code># urls.py\nfrom crane import VersionedNinjaAPI\nfrom myapp.api import router\n\n# Before:\n# api = NinjaAPI()\n\n# After:\napi = VersionedNinjaAPI(api_label=\"default\", app_label=\"myapp\")\napi.add_router(\"/persons\", router)\n\nurlpatterns = [\n    path(\"api/\", api.urls),\n]\n</code></pre> <p>The <code>api_label</code> identifies this API within your app (you might have multiple APIs). The <code>app_label</code> is your Django app name\u2014if omitted, it's auto-detected.</p>"},{"location":"get-started/quickstart/#create-your-first-migration","title":"Create Your First Migration","text":"<p>With your API defined, create the initial migration to capture the current schema:</p> <pre><code>python manage.py makeapimigrations --label default --app myapp --name \"Initial API\"\n</code></pre> <p>This creates a migration file at <code>myapp/api_migrations/default/m_0001_initial_api.py</code> capturing your current API state as version \"1\".</p>"},{"location":"get-started/quickstart/#make-a-schema-change","title":"Make a Schema Change","text":"<p>Now let's evolve the API. Say you want to change <code>email: str</code> to <code>emails: list[str]</code>:</p> <pre><code># Before\nclass PersonOut(Schema):\n    name: str\n    email: str\n\n# After\nclass PersonOut(Schema):\n    name: str\n    emails: list[str]\n</code></pre>"},{"location":"get-started/quickstart/#generate-a-migration","title":"Generate a Migration","text":"<p>Detect and record the change:</p> <pre><code>python manage.py makeapimigrations --label default --app myapp --name \"Change email to emails list\"\n</code></pre> <p>This creates <code>m_0002_change_email_to_emails_list.py</code> with:</p> <ul> <li>The schema delta (what changed)</li> <li>Skeleton transformer functions (you'll implement these)</li> </ul>"},{"location":"get-started/quickstart/#implement-transformers","title":"Implement Transformers","text":"<p>Open the generated migration file. You'll see skeleton transformer functions with <code>NotImplementedError</code>:</p> <pre><code># In m_0002_change_email_to_emails_list.py\n\n# ...\n\n\ndef downgrade_person_out(data: dict) -&gt; dict:\n    \"\"\"2 -&gt; 1: Transform response for v1 clients.\"\"\"\n    raise NotImplementedError\n\ndef upgrade_person_out(data: dict) -&gt; dict:\n    \"\"\"1 -&gt; 2: Transform request from v1 clients.\"\"\"\n    raise NotImplementedError\n\ndata_migrations = DataMigrationSet(\n    schema_downgrades=[\n        SchemaDowngrade(\"#/components/schemas/PersonOut\", downgrade_person_out),\n    ],\n    schema_upgrades=[\n        SchemaUpgrade(\"#/components/schemas/PersonOut\", upgrade_person_out),\n    ],\n)\n</code></pre> <p>Fill in the transformers to convert between the old and new schema shapes:</p> <pre><code>def downgrade_person_out(data: dict) -&gt; dict:\n    \"\"\"2 -&gt; 1: Transform response for v1 clients.\"\"\"\n    emails = data.pop(\"emails\", [])\n    data[\"email\"] = emails[0] if emails else \"\"\n    return data\n\ndef upgrade_person_out(data: dict) -&gt; dict:\n    \"\"\"1 -&gt; 2: Transform request from v1 clients.\"\"\"\n    email = data.pop(\"email\", None)\n    data[\"emails\"] = [email] if email else []\n    return data\n</code></pre>"},{"location":"get-started/quickstart/#test-it","title":"Test It","text":"<p>Your API now serves both versions:</p> <pre><code># Request v2 (latest) - returns new schema\ncurl http://localhost:8000/api/persons/1\n# {\"name\": \"Alice\", \"emails\": [\"alice@example.com\"]}\n\n# Request v1 - returns old schema\ncurl -H \"X-API-Version: 1\" http://localhost:8000/api/persons/1\n# {\"name\": \"Alice\", \"email\": \"alice@example.com\"}\n</code></pre>"},{"location":"get-started/quickstart/#browse-versioned-docs","title":"Browse Versioned Docs","text":"<p>Visit your API's docs page (e.g., <code>/api/docs</code>) to see the Swagger UI with a version selector dropdown. Each version shows the schema as it appeared at that point in time.</p>"},{"location":"get-started/quickstart/#whats-next","title":"What's Next?","text":"<ul> <li>Configuration Reference \u2014 All configuration options</li> <li>Migration Files \u2014 Understand the migration file format</li> <li>Modifying a Schema \u2014 Detailed walkthrough of schema changes</li> </ul>"}]}